---
title: "splatPop"
date: "Last updated: 02 October 2020"
output:
    BiocStyle::html_document:
        toc: true
        toc_float: true
vignette: >
  %\VignetteIndexEntry{splatPop vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette describes the Splat simulation model and the parameters it uses
in more detail.

```{r setup}
suppressPackageStartupMessages({
  library("splatter")
  library("scater")
  library("vcfR")
  library("ggplot2")
  #devtools::load_all(".")
})
```

# Introduction to splatPop

splatPop uses the splat model to simulate single cell count data across a
population. The major addition to splat is the addition of the 
`splatPopSimulateMeans` function, which simulates gene means for each gene for
each individual. These simulated means are then used by `splatPopSimulateSC`, 
essentially a wrapper around the `splatSimulate` function, to apply the 
[splat model](splatter.html) to simulate single cell counts. The figure below
describes the `splatPopSimulateMeans` method. Input parameters that can be 
estimated from real data have double boarders and are shaded by the type of 
real data used for the estimations (blue = single-cell counts, yellow = 
population scale bulk or sc-aggregated RNA-seq data, and green = eQTL mapping 
results). The final output (red) is a matrix of gene means that is used as input
into `splatPopSimulateSC`. 

![The splatPop model for estimating gene means.](splatPop-model.png)


## Simulating population-scale single cell data (Splat-pop)

The ability to simulate single-cell counts for multiple individuals means that
Splatter can simulate data needed for functional genomics studies. Given real
(or simulated) genotype information for a population of samples, Splat-pop
simulates gene mean expression levels across the population, taking into
account population structure and allowing for the simulation of global and
group-specific expression Quantitative Trait Loci (eQTL) effects. Gene means
and variances are simulated from [gamma distributions][gamma] derived from real
population scale RNA-seq data and eQTL effect sizes from a
[gamma distribution][gamma] derived from real eQTL mapping results. Default 
parameters for those distributions are derived from GTEx data, however, they can 
also be estimated from user provided data using `splatPopEstimate`. Simulations 
are generated using `splatPopSimulate`. As part of `splatPopSimulate`, gene 
means for each sample are quantile normalized to match the 
[gamma distribution][gamma] derived from real single-cell RNA-seq data by
`splatEstimate`. This allows one to simulate population scale single-cell counts
from bulk population expression data and eQTL mapping results.


```{r quick-start}
vcf <- mock_vcf(n_samples=6)

params <- setParams(newSplatPopParams(), "nGenes" = 200, "eqtl.n" = 0.4)
sim <- splatPopSimulate(vcf = vcf, params = params)

sim$sc <- logNormCounts(sim$sc)
sim$sc <- runPCA(sim$sc)
plotPCA(sim$sc, colour_by = "Sample")
```

# splatPop in 3 steps

## Step 1: Parameter Estimation 

The parameters needed to simulate gene mean expression levels for a population
are stored in a `splatPopParams` object that contains the same compartments as
the `SplatParams` and additional compartments for population parameters. 
Like with SplatParams, these parameters can be either estimated from real data 
using `splatPopEstimate` or defined by the user using `setParams`.
The default population and eQTL parameters were estimated from bulk RNA-seq data
and eQTL mapping results from GTEx (thyroid tissue). Here is a look at the
default splatPopParams:

```{r default-splatPopParams}
params <- newSplatPopParams()
params
```
This tells us we have "a `Params` object of class `splatPopParams`" and shows
the values of these parameters. As with `SplatParams`, the parameters that can 
be estimated by `splatPopEstimate` are in parentheses, those that can't be 
estimated are in brackets, and those that have been changed from their default
are in ALL CAPS.

In addition to the SplatParams parameters described in detail in the 
[Splat parameters vignette](splat_params.html), the `splatPopParams` object 
contains the following parameters that can be estimated or manually defined:

* **Population parameters**
    * `pop.mean.shape` - Shape parameter for mean expression from population
    scale data.
    * `pop.mean.rate` - Rate parameter for mean expression from population
    scale data.
    * `pop.cv.param` - Shape and rate parameters for the coefficient of
    variation (cv) across individuals from the population scale data, binned by
    mean expression.
* **eQTL effect size parameters**
    * `eqtl.ES.shape` - Shape parameter for eQTL effect sizes.
    * `eqtl.ES.rate` - Rate parameter for eQTL effect sizes.

For example, these parameters can be estimated from user provided bulk or 
single-cell gene means across a population and eQTL mapping results:

```{r eqtlEstimate}
bulk_means <- mock_bulk_matrix(n_genes=500, n_samples=100)
bulk_eqtl <- mock_bulk_eqtl(n_genes=500)
counts <- mockSCE()

params.est <- splatPopEstimate(means = bulk_means,
                               eqtl = bulk_eqtl,
                               counts = counts)
params.est
```

Note that `splatPopEstimate` will only estimate new parameters if the data 
required is provided. For example, if you want to simulate data using default 
gene means and eQTL parameters, but from single-cell parameters estimated from
your own real single-cell counts data, you could run `splatPopEstimate` with 
only the *counts* flag provided.


## Step 2: Simulate gene means 

Given genotype information for a population, `splatPopSimulate`
uses parameters in `splatPopParams` to simulate gene means and single-cell
counts for each individual for each gene. This function combines two functions, 
`splatPopSimulateMeans` and `splatPopSimulateSC`. These can be run separately or
together in `splatPopSimulate`. First we will run `splatPopSimulateMeans` to 
highlight its unique functions. 

Genotype information should be provided as a 
[vcfR object](https://cran.r-project.org/web/packages/vcfR/index.html). A 
mock vcfR object (that does not have realistic population structure) can
be produced using the `mock_vcf` function. Genes can be provided in three ways 
(note that options 2 and 3 overwrite nGene in `splatPopParams`): 

1. Randomly ("gene.source" = "random"): This option will call `mock_gff` to 
generate a random gff file for a specified chromosome. This is the default
option.
2. GFF/GTF ("gene.source" = gff): This option takes a GFF/GTF data.frame object
and selects just the genes.
3. Key ("pop.key" = key): This option uses the genes in a population key
data.frame object that includes columns: *geneID*, *chr*, *gene_mid*.

The number of genes assigned as eGenes is controlled using the **eqtl.n** flag,
where if eqtl.n <= 1, then that percentage of genes are simulated as eGenes.
The eSNP assigned to each eGene will have a minor allele frequency (MAF) between
**eqtl.maf.min** and **eqtl.maf.max** and be no more than **eqtl.dist** away
from the center of the eGene (*gene_mid*). Each eQTL pair is assigned an effect
size from the gamma distribution parameterized in `splatPopEstimate`. By default
all eQTL relationships are considered global (applied to all cells), but
group-specific eQTL can be simulated by setting **nGroups** equal to 2+.
This setting will result in a percent of all eQTL pairs, specified by
**eqtl.group.specific**, being present in a single group. In addition to the
group specific eQTL effects, each group will have group specific differential
expression effects (no associated with a genetic variant) as described in
[splatter](splatter.html).

To summarize, the following `splatPopParams` control parameters can be changed
using `setParams`:

* **Population general parameters (all user defined)**
    * `random.genes` - T/F indicating if random genes should be simulated. 
    If random_genes = FALSE, genes need to be provided using the -gff or -key
    tag.
    * `eqtl.n` - Number (>1) or percent (<=1) of genes to assign eQTL effects.
    * `eqtl.dist` - Maximum distance (bp) between eGene and eSNP.
    * `eqtl.maf.min` - Minimum Minor Allele Frequency (MAF) of eSNPs.
    * `eqtl.maf.max` - Maximum MAF of eSNPs.
    * `eqtl.groups` - Number of groups to simulate.
    * `eqtl.group.specific` - Percent of eQTL effects to make group specific.
    The number of groups is specified using the "group.prob" parameter.

```{r splatPopSimulateMeans}
params <- setParams(newSplatPopParams(), "nGenes" = 200, "eqtl.n" = 0.4)
sim_means <- splatPopSimulateMeans(vcf = vcf, params = params)

round(sim_means$means[1:5, 1:6], digits = 3)
```

The output of `splatPopSimulate()` is an object with two components:
  * `means` - a data.frame (or list of data.frames if `nGroups` > 1) with
  simulated mean gene expression value for each gene (row) and each sample
  (column).
  * `key` - a data.frame listing for all simulated genes: the assigned mean
  and variance (before and after quantile normalization), the assigned eSNP and
  its effect size and type (global/group specific), and other group effects.

Here is a snapshot of the key produced by `splatPopSimulateMeans` above:
```{r eqtlSimulate-show-key}
print(sim_means$key[1:5, ], digits = 2)
```

Gene information can also be provided using a GFF/GTF file read in as a 
data.frame object or from a (complete or partial) splatPop key. The splatPop 
key is generated by `splatPopSimulate` (and `splatPopSimulateMeans`). The 
complete splatPop key can be provided to `splatPopSimulate` to simulate new 
single-cell data with the same gene and eQTL profiles. Alternatively, a partial
splatPop key can be provided to specify:

1. Genes: columns needed: "geneID", "chr", and "gene_mid"
2. Genes and their mean and variance: columns needed:  "geneID", "chr", 
"gene_mid", "exp_mean", and "exp_cv") 

Here is a snapshot of simulated gene means for genes provided as a GFF:

```{r splatPopSimulateMeans-from-gff}
gff <- mock_gff(n_genes = 100)
params_gff <- setParams(params, random.genes = FALSE)
sim_means_gff <- splatPopSimulateMeans(vcf = vcf, params = params_gff, gff=gff)

round(sim_means_gff$means[1:5, 1:6], digits = 3)
```

Here is a snapshot of simulated gene means for genes provided in a splatPop key:

```{r splatPopSimulateMeans-from-key}
partial_key <- sim_means$key[, c("geneID", "chr", "gene_mid")]
sim_means_key <- splatPopSimulateMeans(vcf = vcf, params = params, key=partial_key)

round(sim_means_key$means[1:5, 1:6], digits = 3)
```

A critical step of splatPop is to quantile normalize the simulated gene means
for every individual to match the desired single-cell distribution parameterized
in `splatEstimate()`. If you already have bulk expression data for a population, 
you can use the quantile normalization function directly on that data so that
it can be used as input to `splatPopSimulateSC`. 

```{r quant-normalize-population-data}
bulk_qnorm <- splatPopQuantNorm(newSplatPopParams(), bulk_means)
round(bulk_qnorm[1:5, 1:5], 3)
```


## Step 3: Simulate single cell counts

Finally, single cell level data is simulated using `splatPopSimulateSC`.
The output is a single sce object with a column for each cell for each sample,
labeled as: "SampleX_CellX". If both mean and single-cell simulations are run
together using `splatPopSimulate`, the output contains a list of objects 
including the simulated means, splatPop key, and the sce object described above.

```{r eqtl-splatSimulatePop}
sim_sc <- splatPopSimulateSC(params=params, 
                             sim_means=sim_means$means, 
                             batchCells=50)
sim_sc <- logNormCounts(sim_sc)
sim_sc <- runPCA(sim_sc)
plotPCA(sim_sc, colour_by = "Sample")
```

The `splatSimulatePop` function outputs, in addition to the information output
by `splatSimulate`, the following information:

* **Cell information (`colData`)**
    * `Sample` - The sample number.

## splatPop with group, batch, and path effects

Using the same methods as splat, splatPop allows you to simulate single-cell
counts for a population with group (e.g. cell-types), batch, and path (e.g.
developmental series) effects. Group effects are simulated by
`splatPopSimulateMeans` and applied to the single cell simulations in 
`splatPopSimulateSC`. Path and batch effects are simulated during the single
cell simulation phase. 

### Simulating population scale single-cell data with group effects

The population simulation above is an example of a dataset with a single cell
type across many samples. However, splatPop also allows you to simulate
population-scale data for a mixture of cell-types (i.e. groups).
Two types of group effects are included: group-eQTL and group-differential 
expression (DE) effects. The number of groups to simulate is set using the 
*nGroups* or *group.prob* parameter in `splatPopParams`. The DE effects are 
implemented as in the base splatter package, with the user able to control 
`splatPopParam` parameters including *de.prob*, *de.downProb*, *de.facLoc*,
and *de.facScale*. For group-specific eQTL, the proportion of eQTL to designate
as group-specific eQTL is set using *eqtl.group.specific*. Note that the 
means output from `splatPopSimulate` with group effects is a list of means
data.frames, with a separate data.frame for each group.

When used to simulate sc data with group-specific eQTL,`splatSimulatePop` also
outputs:

* **Cell information (`colData`)**
    * `eQTLGroup` - The group ID for group-specific eQTL.

```{r group-specific-eQTL-simulations}
params2 <- setParams(params, 
                     batchCells = 40,
                     group.prob = c(0.5, 0.5))

sim_sc_gr2 <- splatPopSimulate(vcf=vcf, params=params2)

sim_sc_gr2$sc <- logNormCounts(sim_sc_gr2$sc)
sim_sc_gr2$sc <- runPCA(sim_sc_gr2$sc)
plotPCA(sim_sc_gr2$sc, colour_by = "popGroup", shape_by = "Sample")
```

These are relatively small group-effects, but they can be increased by adjusting 
the *eqtl.group.specific* and *de* parameters: 

```{r group-specific-eQTL-simulations-bigger}
params2 <- setParams(params2, 
                     eqtl.group.specific = 0.6,
                     de.prob = 0.75,
                     de.facLoc = 0.8, 
                     de.facScale = 0.6)

sim_sc_gr2 <- splatPopSimulate(vcf=vcf, params=params2)

sim_sc_gr2$sc <- logNormCounts(sim_sc_gr2$sc)
sim_sc_gr2$sc <- runPCA(sim_sc_gr2$sc)
plotPCA(sim_sc_gr2$sc, colour_by = "popGroup", shape_by = "Sample")
```

### Simulate SC data for population with path and batch effects

As in `splatSimulate`, users can also simulate single-cell data with path or 
batch effects using the `method` tag in `splatSimulatePop`. Note that you can
also set *method = group*, but this is done automatically by setting the 
*group.prob* parameter. 

```{r simulate-population-with-batch-effects}
sim.pop.batches <- splatPopSimulate(vcf = vcf, params = params,
                                    batchCells = c(20, 20),
                                    batch.facLoc = 0.2,
                                    batch.facScale = 0.3)
sim.pop.batches$sc <- logNormCounts(sim.pop.batches$sc)
sim.pop.batches$sc <- runPCA(sim.pop.batches$sc)
plotPCA(sim.pop.batches$sc, colour_by = "Batch", shape_by = "Sample",
        ncomponents = 5:6)

```

```{r simulate-population-with-path-effects}
sim.pop.paths <- splatPopSimulate(vcf = vcf, params = params,
                                  method = 'paths',
                                  de.prob = 0.5)
sim.pop.paths$sc <- logNormCounts(sim.pop.paths$sc)
sim.pop.paths$sc <- runPCA(sim.pop.paths$sc)
plotPCA(sim.pop.paths$sc, colour_by = "Step", shape_by = "Sample",
        ncomponents = 5:6)
```


